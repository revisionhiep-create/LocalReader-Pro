<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LocalReader - Pro Edition v1.3</title>
    <!-- Local Dependencies -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="lib/lucide.min.js"></script>
    <script src="lib/pdf.min.js"></script>
    
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        border: "hsl(240 3.7% 15.9%)",
                        background: "#000000",
                        foreground: "#d1d5db",
                        card: "#09090b",
                        accent: "#3b82f6",
                    }
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');
        body { font-family: 'Inter', sans-serif; background-color: #000000; color: #d1d5db; }
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #09090b; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #27272a; border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #3f3f46; }
        
        .active-sentence { background-color: rgba(59, 130, 246, 0.2); border-left: 3px solid #3b82f6; border-radius: 2px; }
        .sentence { transition: all 0.2s; padding: 4px 8px; cursor: pointer; display: block; margin-bottom: 0.5rem; }
        .sentence:hover { background-color: rgba(255, 255, 255, 0.05); }
    </style>
</head>
<body class="min-h-screen selection:bg-blue-500/30 overflow-hidden">

    <div class="flex h-screen">
        <!-- Sidebar -->
        <aside class="w-80 bg-card border-r border-border flex flex-col shrink-0">
            <div class="p-6 border-b border-border">
                <div class="flex items-center justify-between mb-6">
                    <div class="flex items-center gap-3">
                        <div class="p-2 bg-blue-600 rounded-lg text-white">
                            <i data-lucide="book-open" class="w-5 h-5"></i>
                        </div>
                        <h1 class="font-bold text-lg tracking-tight text-white">LocalReader</h1>
                    </div>
                    <div id="engineStatusDot" class="w-2.5 h-2.5 rounded-full bg-zinc-700 shadow-[0_0_8px_rgba(0,0,0,0.5)]" title="Engine Status"></div>
                </div>
                
                <div id="setupArea" class="mb-4" style="display: none;">
                    <button id="setupBtn" class="w-full flex items-center justify-center gap-2 px-4 py-2.5 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-all shadow-lg shadow-blue-900/20">
                        <i data-lucide="download-cloud" class="w-4 h-4"></i>
                        <span class="text-sm font-bold">Setup Voice Engine</span>
                    </button>
                </div>

                <div id="uploadArea" class="mb-4" style="display: none;">
                    <label class="w-full flex items-center justify-center gap-2 px-4 py-2.5 bg-zinc-800 hover:bg-zinc-700 text-white rounded-lg cursor-pointer transition-all border border-zinc-700">
                        <i data-lucide="plus" class="w-4 h-4"></i>
                        <span class="text-sm font-semibold">Upload Book (PDF/EPUB)</span>
                        <input type="file" id="pdfUpload" class="hidden" accept=".pdf,.epub">
                    </label>
                </div>
            </div>

            <!-- Tabs -->
            <div class="flex border-b border-border">
                <button id="tabLibrary" class="flex-1 py-3 text-[10px] font-bold uppercase tracking-widest border-b-2 border-blue-600 text-blue-500 bg-white/5">Library</button>
                <button id="tabRules" class="flex-1 py-3 text-[10px] font-bold uppercase tracking-widest border-b-2 border-transparent text-zinc-500 hover:text-zinc-300">Rules</button>
                <button id="tabIgnore" class="flex-1 py-3 text-[10px] font-bold uppercase tracking-widest border-b-2 border-transparent text-zinc-500 hover:text-zinc-300">Ignore</button>
            </div>

            <!-- Content -->
            <div class="flex-1 overflow-hidden flex flex-col">
                <div id="libraryPanel" class="flex-1 overflow-y-auto custom-scrollbar p-4 space-y-2"></div>
                <div id="rulesPanel" class="flex-1 overflow-y-auto custom-scrollbar p-4 space-y-4 hidden">
                    <div class="flex justify-between items-center">
                        <h3 class="text-xs font-bold uppercase tracking-widest text-zinc-500">Custom Rules</h3>
                        <button id="addRuleBtn" class="p-1.5 bg-zinc-800 hover:bg-zinc-700 text-zinc-300 rounded-md"><i data-lucide="plus" class="w-3.5 h-3.5"></i></button>
                    </div>
                    <div id="rulesList" class="space-y-3"></div>
                </div>
                <div id="ignorePanel" class="flex-1 overflow-y-auto custom-scrollbar p-4 space-y-4 hidden">
                    <div class="flex justify-between items-center">
                        <h3 class="text-xs font-bold uppercase tracking-widest text-zinc-500">Ignore List</h3>
                        <button id="addIgnoreBtn" class="p-1.5 bg-zinc-800 hover:bg-zinc-700 text-zinc-300 rounded-md"><i data-lucide="plus" class="w-3.5 h-3.5"></i></button>
                    </div>
                    <div id="ignoreListUI" class="space-y-2"></div>
                </div>
            </div>

            <!-- Settings -->
            <div class="p-6 border-t border-border bg-black/20 space-y-4">
                <div>
                    <label class="text-[10px] font-bold text-zinc-500 uppercase tracking-widest mb-2 block">Voice Selection</label>
                    <select id="voiceSelect" class="w-full bg-zinc-900 text-xs font-medium border border-zinc-800 rounded px-2 py-1.5 outline-none text-zinc-300 focus:border-blue-500">
                        <option value="af_sky">AF Sky (Female)</option>
                        <option value="af_bella" selected>AF Bella (Female)</option>
                        <option value="af_nicole">AF Nicole (Female)</option>
                        <option value="af_sarah">AF Sarah (Female)</option>
                        <option value="am_adam">AM Adam (Male)</option>
                        <option value="am_michael">AM Michael (Male)</option>
                        <option value="bf_isabella">BF Isabella (British Female)</option>
                        <option value="bm_lewis">BM Lewis (British Male)</option>
                    </select>
                </div>
                <div>
                    <label class="text-[10px] font-bold text-zinc-500 uppercase tracking-widest mb-2 block">Speed (<span id="speedVal">1.00</span>x)</label>
                    <input type="range" id="speedRange" min="0.5" max="3.0" step="0.05" value="1.00" class="w-full h-1 bg-zinc-800 rounded-lg appearance-none cursor-pointer accent-blue-600">
                </div>
            </div>
        </aside>

        <main class="flex-1 flex flex-col bg-black relative">
            <header class="h-16 border-b border-border flex items-center px-6 bg-card/80 backdrop-blur-md shrink-0">
                <span id="docTitle" class="font-semibold text-sm truncate text-zinc-300 italic flex-1 mr-4">No document selected</span>
                <div id="pageNav" class="hidden flex items-center gap-2 px-3 py-1 bg-zinc-900 rounded-full border border-zinc-800 text-xs shrink-0">
                    <button id="prevPage" class="hover:text-blue-400 p-1"><i data-lucide="chevron-left" class="w-4 h-4"></i></button>
                    <div class="flex items-center gap-1.5 px-1">
                        <span class="text-zinc-500 font-medium">Pg</span>
                        <input type="number" id="pageInput" class="w-10 bg-zinc-800 border-none rounded text-center text-zinc-200 outline-none focus:ring-1 focus:ring-blue-500 [appearance:textfield] [&::-webkit-outer-spin-button]:appearance-none [&::-webkit-inner-spin-button]:appearance-none" min="1" value="1">
                        <span class="text-zinc-500">/ <span id="pageTotal">1</span></span>
                    </div>
                    <button id="nextPage" class="hover:text-blue-400 p-1"><i data-lucide="chevron-right" class="w-4 h-4"></i></button>
                </div>
            </header>

            <div id="readerContent" class="flex-1 overflow-y-auto custom-scrollbar p-8 lg:px-24 xl:px-48 pb-32">
                <div id="emptyState" class="h-full flex flex-col items-center justify-center text-center space-y-4">
                    <div class="w-20 h-20 bg-zinc-900 rounded-full flex items-center justify-center text-zinc-700"><i data-lucide="file-text" class="w-10 h-10"></i></div>
                    <h2 class="text-xl font-bold text-zinc-300">Welcome to LocalReader</h2>
                    <p class="text-zinc-500 text-sm max-w-sm">Select a document or upload a new PDF.</p>
                </div>
                <div id="textContent" class="hidden"></div>
            </div>

            <!-- Controls -->
            <div id="controls" class="absolute bottom-8 left-1/2 -translate-x-1/2 bg-zinc-900/95 backdrop-blur-xl border border-zinc-800 p-4 rounded-2xl shadow-2xl flex items-center gap-6 hidden min-w-[400px]">
                <button id="playBtn" class="w-14 h-14 bg-blue-600 hover:bg-blue-700 text-white rounded-full flex items-center justify-center transition-all hover:scale-105 active:scale-95 shadow-lg shadow-blue-900/40 shrink-0">
                    <i data-lucide="play" id="playIcon" class="w-6 h-6 fill-current"></i>
                </button>
                <div class="flex flex-col flex-1 min-w-0">
                    <span id="currentSentencePreview" class="text-[10px] font-bold text-zinc-400 uppercase tracking-widest truncate">Ready</span>
                    <div class="flex items-center gap-4 mt-1.5">
                        <button id="skipBack" class="text-zinc-500 hover:text-white p-1"><i data-lucide="skip-back" class="w-5 h-5"></i></button>
                        <button id="skipForward" class="text-zinc-500 hover:text-white p-1"><i data-lucide="skip-forward" class="w-5 h-5"></i></button>
                        <div class="h-4 w-px bg-zinc-800 mx-1"></div>
                        <span id="bookmarkStatus" class="text-[9px] font-bold text-blue-500 uppercase tracking-widest flex items-center gap-1.5"><i data-lucide="bookmark" class="w-3 h-3"></i> Auto-Saving</span>
                    </div>
                </div>
                <audio id="audioPlayer" class="hidden"></audio>
            </div>
        </main>
    </div>

    <!-- Toast -->
    <div id="toast" class="fixed top-4 right-4 bg-red-900/95 border border-red-700 text-white px-6 py-4 rounded-xl shadow-2xl hidden z-50">
        <div class="flex items-center gap-3">
            <i data-lucide="alert-circle" class="w-5 h-5 text-red-300"></i>
            <span id="toastMsg" class="text-sm font-semibold"></span>
        </div>
    </div>

    <!-- Visual Debugger Overlay REMOVED -->

    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'lib/pdf.worker.min.js';

        let currentDoc = null, currentPages = [], currentPageIndex = 0, currentSentenceIndex = 0, sentences = [], isPlaying = false, rules = [], ignoreList = [];
        const API_URL = 'http://127.0.0.1:8000';

        const pdfUpload = document.getElementById('pdfUpload'), uploadArea = document.getElementById('uploadArea'), libraryPanel = document.getElementById('libraryPanel'), rulesPanel = document.getElementById('rulesPanel'), 
              ignorePanel = document.getElementById('ignorePanel'), rulesList = document.getElementById('rulesList'), ignoreListUI = document.getElementById('ignoreListUI'), 
              tabLibrary = document.getElementById('tabLibrary'), tabRules = document.getElementById('tabRules'), tabIgnore = document.getElementById('tabIgnore'), 
              textContent = document.getElementById('textContent'), readerContent = document.getElementById('readerContent'), emptyState = document.getElementById('emptyState'), 
              docTitle = document.getElementById('docTitle'), pageInput = document.getElementById('pageInput'), pageTotal = document.getElementById('pageTotal'), 
              pageNav = document.getElementById('pageNav'), controls = document.getElementById('controls'), playBtn = document.getElementById('playBtn'), 
              playIcon = document.getElementById('playIcon'), currentSentencePreview = document.getElementById('currentSentencePreview'), 
              audioPlayer = document.getElementById('audioPlayer'), speedRange = document.getElementById('speedRange'), speedVal = document.getElementById('speedVal'), 
              voiceSelect = document.getElementById('voiceSelect'), addRuleBtn = document.getElementById('addRuleBtn'), setupArea = document.getElementById('setupArea'), 
              setupBtn = document.getElementById('setupBtn'), engineStatusDot = document.getElementById('engineStatusDot'), toast = document.getElementById('toast');

        lucide.createIcons();

        async function init() {
            try {
                // 1. Start all fetches in parallel
                const settingsPromise = fetch(`${API_URL}/api/settings`).then(r => r.json());
                const libraryPromise = loadLibrary();

                const settings = await settingsPromise;
                
                rules = settings.pronunciationRules || [];
                ignoreList = settings.ignoreList || [];
                const savedVoice = settings.voice_id;
                const savedSpeed = settings.speed;

                // 2. Set speed independently (immediate)
                if (savedSpeed) {
                    speedRange.value = savedSpeed;
                    speedVal.textContent = parseFloat(savedSpeed).toFixed(2);
                }

                // 3. Wait for UI components to be fully ready for voice selection
                const applyVoice = () => {
                    const optionsReady = voiceSelect.options.length > 0;
                    if (savedVoice && optionsReady) {
                        const exists = Array.from(voiceSelect.options).some(opt => opt.value === savedVoice);
                        if (exists) {
                            voiceSelect.value = savedVoice;
                        } else {
                            voiceSelect.selectedIndex = 0;
                        }
                        return true;
                    } else if (optionsReady) {
                        return true;
                    }
                    return false;
                };

                if (!applyVoice()) {
                    let attempts = 0;
                    const interval = setInterval(() => {
                        attempts++;
                        if (applyVoice() || attempts > 20) clearInterval(interval);
                    }, 100);
                }

                // 4. Finalize other systems
                await libraryPromise;
                renderRules();
                renderIgnoreList();
                startStatusPolling();

            } catch (e) { 
                console.error("Init error", e);
            }
        }

        async function saveSettings() {
            try {
                const config = { 
                    pronunciationRules: rules, 
                    ignoreList: ignoreList,
                    voice_id: voiceSelect.value,
                    speed: parseFloat(speedRange.value)
                };
                await fetch(`${API_URL}/api/settings`, { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify(config) 
                });
            } catch (err) {
                console.error("Save failed:", err);
                showToast("Failed to save settings to disk");
            }
        }

        voiceSelect.onchange = saveSettings;
        speedRange.oninput = (e) => {
            const val = parseFloat(e.target.value).toFixed(2);
            speedVal.textContent = val;
        };
        speedRange.onchange = saveSettings; // Save only on release to avoid spamming the FS

        let isEngineReady = false;
        let lastSystemState = null;
        async function startStatusPolling() {
            const poll = async () => {
                try {
                    const res = await fetch(`${API_URL}/api/system/status?t=${Date.now()}`);
                    const status = await res.json();
                    isEngineReady = status.model_loaded;
                    
                    const currentState = `${status.is_downloading}-${status.is_loading}-${status.model_loaded}`;
                    if (currentState !== lastSystemState) {
                        lastSystemState = currentState;
                        if (status.is_downloading) {
                            engineStatusDot.className = "w-2.5 h-2.5 rounded-full bg-blue-500 animate-pulse";
                            setupArea.style.display = 'block';
                            uploadArea.style.display = 'none';
                            setupBtn.disabled = true;
                            setupBtn.innerHTML = '<i data-lucide="loader-2" class="w-4 h-4 animate-spin"></i><span class="text-sm font-bold">Downloading...</span>';
                            lucide.createIcons();
                        } else if (status.is_loading) { 
                            engineStatusDot.className = "w-2.5 h-2.5 rounded-full bg-yellow-500 animate-pulse"; 
                            setupArea.style.display = 'none';
                            uploadArea.style.display = 'block';
                        }
                        else if (status.model_loaded) { 
                            engineStatusDot.className = "w-2.5 h-2.5 rounded-full bg-green-500 shadow-[0_0_8px_rgba(34,197,94,0.6)]"; 
                            setupArea.style.display = 'none';
                            uploadArea.style.display = 'block';
                        }
                        else { 
                            engineStatusDot.className = "w-2.5 h-2.5 rounded-full bg-red-600"; 
                            setupArea.style.display = 'block';
                            uploadArea.style.display = 'none';
                            setupBtn.disabled = false;
                            setupBtn.innerHTML = '<i data-lucide="download-cloud" class="w-4 h-4"></i><span class="text-sm font-bold">Setup Voice Engine</span>';
                            lucide.createIcons();
                        }
                    }
                } catch (e) { engineStatusDot.className = "w-2.5 h-2.5 rounded-full bg-zinc-700"; }
                setTimeout(poll, 2000);
            };
            poll();
        }

        setupBtn.onclick = () => fetch(`${API_URL}/api/system/setup`, { method: 'POST' });
        function showToast(msg) { document.getElementById('toastMsg').textContent = msg; toast.classList.remove('hidden'); setTimeout(() => toast.classList.add('hidden'), 5000); }

        tabLibrary.onclick = () => { tabLibrary.className = "flex-1 py-3 text-[10px] font-bold uppercase tracking-widest border-b-2 border-blue-600 text-blue-500 bg-white/5"; tabRules.className = tabIgnore.className = "flex-1 py-3 text-[10px] font-bold uppercase tracking-widest border-b-2 border-transparent text-zinc-500 hover:text-zinc-300"; libraryPanel.classList.remove('hidden'); rulesPanel.classList.add('hidden'); ignorePanel.classList.add('hidden'); };
        tabRules.onclick = () => { tabRules.className = "flex-1 py-3 text-[10px] font-bold uppercase tracking-widest border-b-2 border-blue-600 text-blue-500 bg-white/5"; tabLibrary.className = tabIgnore.className = "flex-1 py-3 text-[10px] font-bold uppercase tracking-widest border-b-2 border-transparent text-zinc-500 hover:text-zinc-300"; rulesPanel.classList.remove('hidden'); libraryPanel.classList.add('hidden'); ignorePanel.classList.add('hidden'); };
        tabIgnore.onclick = () => { tabIgnore.className = "flex-1 py-3 text-[10px] font-bold uppercase tracking-widest border-b-2 border-blue-600 text-blue-500 bg-white/5"; tabLibrary.className = tabRules.className = "flex-1 py-3 text-[10px] font-bold uppercase tracking-widest border-b-2 border-transparent text-zinc-500 hover:text-zinc-300"; ignorePanel.classList.remove('hidden'); libraryPanel.classList.add('hidden'); rulesPanel.classList.add('hidden'); };

        document.getElementById('addIgnoreBtn').onclick = () => { ignoreList.push(''); renderIgnoreList(); saveSettings(); };
        function renderIgnoreList() {
            const fragment = document.createDocumentFragment();
            ignoreList.forEach((item, i) => {
                const div = document.createElement('div'); div.className = 'flex items-center gap-2 bg-zinc-900/80 p-2 rounded-lg border border-zinc-800';
                div.innerHTML = `<input type="text" value="${item}" class="flex-1 bg-black text-[10px] p-1.5 border border-zinc-800 rounded outline-none text-zinc-300" onchange="ignoreList[${i}]=this.value;saveSettings()">
                                <button onclick="ignoreList.splice(${i},1);renderIgnoreList();saveSettings()" class="text-zinc-600 hover:text-red-500 p-1"><i data-lucide="x" class="w-3.5 h-3.5"></i></button>`;
                fragment.appendChild(div);
            });
            ignoreListUI.innerHTML = '';
            ignoreListUI.appendChild(fragment);
            lucide.createIcons();
        }

        addRuleBtn.onclick = () => { rules.push({ id: crypto.randomUUID(), original: '', replacement: '', match_case: false, word_boundary: true }); renderRules(); saveSettings(); };
        window.updateRule = (id, upd) => { rules = rules.map(r => r.id === id ? {...r, ...upd} : r); renderRules(); saveSettings(); };
        function renderRules() {
            const fragment = document.createDocumentFragment();
            rules.forEach(r => {
                const div = document.createElement('div'); div.className = 'bg-zinc-900/80 p-3 rounded-xl border border-zinc-800 space-y-2';
                div.innerHTML = `<div class="grid grid-cols-1 gap-1.5"><input type="text" placeholder="Original" value="${r.original}" class="bg-black text-[10px] p-2 border border-zinc-800 rounded-md text-zinc-300" onchange="updateRule('${r.id}',{original:this.value})">
                                <input type="text" placeholder="Replacement" value="${r.replacement}" class="bg-black text-[10px] p-2 border border-zinc-800 rounded-md text-zinc-300" onchange="updateRule('${r.id}',{replacement:this.value})"></div>
                                <div class="flex items-center justify-between"><div class="flex gap-2">
                                <button onclick="updateRule('${r.id}',{match_case:${!r.match_case}})" class="p-1 rounded-md ${r.match_case?'bg-blue-600':'bg-zinc-800'}"><i data-lucide="case-sensitive" class="w-3.5 h-3.5"></i></button>
                                <button onclick="updateRule('${r.id}',{word_boundary:${!r.word_boundary}})" class="p-1 rounded-md ${r.word_boundary?'bg-blue-600':'bg-zinc-800'}"><i data-lucide="whole-word" class="w-3.5 h-3.5"></i></button></div>
                                <button onclick="rules=rules.filter(x=>x.id!=='${r.id}');renderRules();saveSettings()" class="text-zinc-600 hover:text-red-500"><i data-lucide="trash-2" class="w-3.5 h-3.5"></i></button></div>`;
                fragment.appendChild(div);
            });
            rulesList.innerHTML = '';
            rulesList.appendChild(fragment);
            lucide.createIcons();
        }

        async function loadLibrary() {
            try {
                const res = await fetch(`${API_URL}/api/library?t=${Date.now()}`);
                const items = await res.json();
                console.log("Library items loaded:", items);
                libraryPanel.innerHTML = '';
                if (!Array.isArray(items) || items.length === 0) {
                    libraryPanel.innerHTML = '<div class="p-4 text-xs text-zinc-500 italic">Library is empty. Upload a PDF to start.</div>';
                    return;
                }
                const fragment = document.createDocumentFragment();
                items.sort((a,b) => (b.lastAccessed||0) - (a.lastAccessed||0)).forEach(item => {
                    const isSelected = currentDoc?.id === item.id;
                    const div = document.createElement('div'); 
                    div.className = `group p-3 rounded-xl cursor-pointer border transition-all ${isSelected ? 'bg-blue-600/10 border-blue-600/50 text-blue-400' : 'bg-zinc-900/50 border-zinc-800 text-zinc-400 hover:border-zinc-700'}`;
                    
                    div.innerHTML = `
                        <div class="flex items-start justify-between gap-2">
                            <div class="flex items-start gap-3 min-w-0" onclick="window.selectDocById('${item.id}')">
                                <i data-lucide="file" class="w-4 h-4 mt-0.5 shrink-0"></i>
                                <div class="min-w-0">
                                    <p class="text-xs font-bold leading-tight break-words">${item.fileName}</p>
                                    <p class="text-[10px] opacity-60 mt-1">Page ${(item.currentPage||0)+1}/${item.totalPages}</p>
                                </div>
                            </div>
                            <button onclick="window.deleteDocument(event, '${item.id}')" class="p-1 hover:bg-red-500/20 hover:text-red-500 rounded-md transition-colors opacity-0 group-hover:opacity-100 shrink-0">
                                <i data-lucide="x" class="w-3.5 h-3.5"></i>
                            </button>
                        </div>`;
                    
                    fragment.appendChild(div);
                });
                libraryPanel.appendChild(fragment);
                lucide.createIcons();
            } catch (e) {
                console.error("Load library error:", e);
                libraryPanel.innerHTML = '<div class="p-4 text-xs text-red-500 italic">Failed to load library.</div>';
            }
        }

        window.selectDocById = async (id) => {
            const res = await fetch(`${API_URL}/api/library`);
            const items = await res.json();
            const item = items.find(i => i.id === id);
            if (item) selectDocument(item);
        };

        window.deleteDocument = async (e, id) => {
            e.stopPropagation();
            if (!confirm("Delete this document?")) return;
            try {
                const res = await fetch(`${API_URL}/api/library/${id}`, { method: 'DELETE' });
                if (res.ok) {
                    if (currentDoc?.id === id) {
                        currentDoc = null;
                        currentPages = [];
                        textContent.innerHTML = '';
                        docTitle.textContent = 'No document selected';
                        pageNav.classList.add('hidden');
                        controls.classList.add('hidden');
                        emptyState.classList.remove('hidden');
                        textContent.classList.add('hidden');
                        stopPlayback();
                    }
                    loadLibrary();
                }
            } catch (e) { showToast("Failed to delete document"); }
        };

        async function selectDocument(item) {
            currentDoc = item;
            const res = await fetch(`${API_URL}/api/library/content/${item.id}`);
            const data = await res.json();
            currentPages = data.pages; currentPageIndex = item.currentPage || 0; currentSentenceIndex = item.lastSentenceIndex || 0;
            docTitle.textContent = item.fileName; pageNav.classList.remove('hidden'); controls.classList.remove('hidden'); emptyState.classList.add('hidden'); textContent.classList.remove('hidden');
            renderPage(); loadLibrary();
        }

        function renderPage() {
            const text = currentPages[currentPageIndex];
            // Split by sentence but keep trailing quotes
            const rawSentences = text.match(/[^.!?]+[.!?]+[\"\'\u201c\u2018\u201d\u2019]*(?:\s|$)|[^.!?]+$/g) || [text];
            
            // Smart Merge: Combine very short sentences (e.g. artifacts or abbreviations)
            sentences = [];
            for (let i = 0; i < rawSentences.length; i++) {
                let s = rawSentences[i].trim()
                    .replace(/^[\"\'\u201c\u2018\u201d\u2019]+(?=[\"\'\u201c\u2018\u201d\u2019])/, '') // Deduplicate leading quotes
                    .replace(/[\"\'\u201c\u2018\u201d\u2019]+$/, (match) => match.length > 1 ? match[0] : match); // Deduplicate trailing quotes

                if (!s) continue;
                // If current sentence is very short and doesn't end in punctuation, or if next sentence is very short
                if (sentences.length > 0 && (sentences[sentences.length-1].length < 15 || !/[.!?]/.test(sentences[sentences.length-1]))) {
                    sentences[sentences.length-1] += " " + s;
                } else {
                    sentences.push(s);
                }
            }

            const fragment = document.createDocumentFragment();
            sentences.forEach((s, i) => {
                const span = document.createElement('span'); 
                span.className = `sentence ${i===currentSentenceIndex?'active-sentence':''}`; 
                span.textContent = s; 
                span.onclick = () => jumpToSentence(i); 
                fragment.appendChild(span);
            });
            textContent.innerHTML = '';
            textContent.appendChild(fragment);
            pageInput.value = currentPageIndex + 1; pageTotal.textContent = currentPages.length; readerContent.scrollTop = 0;
            currentSentencePreview.textContent = (sentences[currentSentenceIndex] || "").substring(0, 50) + "...";
        }

        async function extractTextFromPage(page) {
            const content = await page.getTextContent();
            let text = "", lastItem = null;
            
            // First pass: detect average char width for gap analysis
            let totalWidth = 0, charCount = 0;
            for (let item of content.items) {
                if (item.str.trim().length > 0) {
                    totalWidth += item.width;
                    charCount += item.str.length;
                }
            }
            const avgCharWidth = charCount > 0 ? totalWidth / charCount : 5;

            for (let item of content.items) {
                let str = item.str.replace(/\ufffd/g, '"');
                // Normalize ligatures if any leaked through
                str = str.normalize('NFKC'); 
                
                if (!str.trim() && str !== " ") continue;
                
                if (lastItem) {
                    const lastY = lastItem.transform[5], currentY = item.transform[5];
                    const lastX = lastItem.transform[4], lastWidth = lastItem.width;
                    const lastHeight = Math.abs(lastItem.transform[0]);
                    const currentX = item.transform[4];
                    
                    const verticalGap = Math.abs(currentY - lastY);
                    
                    if (verticalGap > (lastHeight * 0.4)) {
                        // New line detection
                        const isTerminal = /[.!?;:]/.test(text.trimEnd().slice(-1));
                        // If it's not a terminal punctuation, it's likely a wrapped line
                        if (!isTerminal && verticalGap < (lastHeight * 2.5)) {
                            if (!text.endsWith(" ") && !str.startsWith(" ")) text += " ";
                        } else {
                            text = text.trimEnd() + "\n";
                        }
                    } else {
                        // Horizontal gap analysis
                        const gap = currentX - (lastX + lastWidth);
                        
                        // If gap is significant but not too large, add a space
                        // Proportional to average char width or font height
                        if (gap > Math.max(1.5, avgCharWidth * 0.25)) {
                            const lastChar = text.trimEnd().slice(-1);
                            const nextChar = str.trimStart().charAt(0);
                            
                            // Don't add space if we are inside quotes or brackets
                            const noSpaceBefore = /[\"\'\(\[\{\u201c\u2018]/.test(lastChar);
                            const noSpaceAfter = /[\"\'\)\\\}\]\u201d\u2019]/.test(nextChar);
                            
                            if (!text.endsWith(" ") && !str.startsWith(" ") && !noSpaceBefore && !noSpaceAfter) {
                                text += " ";
                            }
                        }
                    }
                }
                text += str;
                lastItem = item;
            }
            
            // Post-process: clean up multiple spaces and artifacts
            return text.trim()
                .replace(/[ \t]+/g, ' ')
                .replace(/\n\s+/g, '\n')
                .replace(/-\s*\n\s*/g, ''); // Fix hyphenated words at line breaks
        }

        pdfUpload.onchange = async (e) => {
            const file = e.target.files[0]; if (!file) return;
            const isEpub = file.name.toLowerCase().endsWith('.epub');
            showToast(isEpub ? "Converting EPUB to PDF..." : "Processing PDF...");
            
            if (isEpub) {
                const formData = new FormData();
                formData.append('file', file);
                try {
                    const res = await fetch(`${API_URL}/api/convert/epub`, { method: 'POST', body: formData });
                    if (!res.ok) {
                        const err = await res.json();
                        throw new Error(err.detail || "Conversion failed");
                    }
                    const pdfBlob = await res.blob();
                    const convertedFileName = file.name.replace(/\.[^/.]+$/, "") + "_converted.pdf";
                    processPdfBlob(pdfBlob, convertedFileName);
                } catch (e) {
                    showToast(e.message);
                }
            } else {
                processPdfBlob(file, file.name);
            }
            e.target.value = ''; // Reset
        };

        async function processPdfBlob(blob, fileName) {
            const reader = new FileReader();
            reader.onload = async function() {
                try {
                    const pdf = await pdfjsLib.getDocument(new Uint8Array(this.result)).promise;
                    const pagesText = [];
                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        pagesText.push(await extractTextFromPage(page));
                    }
                    const docId = crypto.randomUUID();
                    const newDoc = { id: docId, fileName: fileName, totalPages: pdf.numPages, currentPage: 0, lastSentenceIndex: 0, lastAccessed: Date.now() };
                    await fetch(`${API_URL}/api/library`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(newDoc) });
                    await fetch(`${API_URL}/api/library/content`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ id: docId, pages: pagesText }) });
                    selectDocument(newDoc);
                    showToast("Book added to library");
                } catch (err) {
                    console.error("PDF processing error:", err);
                    showToast("Failed to process document: " + err.message);
                }
            };
            reader.readAsArrayBuffer(blob);
        }

        async function playNext() {
            if (!isPlaying || !isEngineReady) { stopPlayback(); return; }
            const text = sentences[currentSentenceIndex];
            if (!text) {
                if (currentPageIndex < currentPages.length - 1) { currentPageIndex++; currentSentenceIndex = 0; renderPage(); playNext(); }
                else stopPlayback();
                return;
            }
            document.querySelectorAll('.sentence').forEach((el, i) => el.className = `sentence ${i===currentSentenceIndex?'active-sentence':''}`);
            const active = document.querySelector('.active-sentence'); if (active) active.scrollIntoView({ behavior: 'smooth', block: 'center' });
            currentSentencePreview.textContent = text.substring(0, 50) + "...";
            saveProgress();
            console.log(`Synthesizing sentence ${currentSentenceIndex}: "${text.substring(0, 30)}..."`);
            try {
                const res = await fetch(`${API_URL}/api/synthesize`, { 
                    method: 'POST', 
                    headers: { 'Content-Type': 'application/json' }, 
                    body: JSON.stringify({ 
                        text, 
                        voice: voiceSelect.value, 
                        speed: parseFloat(speedRange.value), 
                        rules, 
                        ignore_list: ignoreList 
                    }) 
                });
                
                if (!res.ok) {
                    const err = await res.json();
                    throw new Error(err.detail || "Synthesis failed");
                }
                
                const blob = await res.blob();
                console.log(`Audio blob received: ${blob.size} bytes`);
                if (blob.size < 1000) {
                    console.warn("Audio blob is suspiciously small.");
                }
                
                const url = URL.createObjectURL(blob);
                audioPlayer.src = url;
                
                audioPlayer.onended = () => { 
                    URL.revokeObjectURL(url); 
                    currentSentenceIndex++; 
                    console.log(`Sentence ended, moving to ${currentSentenceIndex}`);
                    playNext(); 
                };

                const playPromise = audioPlayer.play();
                if (playPromise !== undefined) {
                    playPromise.catch(error => {
                        console.error("Audio play failed:", error);
                        showToast("Playback error: " + error.message);
                        stopPlayback();
                    });
                }
            } catch (e) { 
                console.error("Synthesis error:", e);
                showToast(e.message); 
                stopPlayback(); 
            }
        }

        function stopPlayback() { 
            isPlaying = false; 
            const icon = document.getElementById('playIcon');
            if (icon) {
                icon.setAttribute('data-lucide', 'play');
                lucide.createIcons();
            }
            audioPlayer.pause(); 
            audioPlayer.src = ""; 
        }

        function togglePlayback() {
            if (isPlaying) {
                stopPlayback(); 
            } else { 
                isPlaying = true; 
                const icon = document.getElementById('playIcon');
                if (icon) {
                    icon.setAttribute('data-lucide', 'pause');
                    lucide.createIcons();
                }
                playNext(); 
            }
        }

        playBtn.onclick = togglePlayback;

        window.addEventListener('keydown', (e) => {
            const active = document.activeElement;
            const isTyping = active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable;
            
            if (isTyping) return;

            if (e.code === 'Space') {
                e.preventDefault(); // Prevent scrolling
                togglePlayback();
            } else if (e.code === 'ArrowLeft') {
                e.preventDefault();
                document.getElementById('skipBack').click();
            } else if (e.code === 'ArrowRight') {
                e.preventDefault();
                document.getElementById('skipForward').click();
            }
        });

        document.getElementById('skipBack').onclick = () => {
            if (currentSentenceIndex > 0) {
                jumpToSentence(currentSentenceIndex - 1);
            } else {
                showToast("Beginning of page");
            }
        };

        document.getElementById('skipForward').onclick = () => {
            if (currentSentenceIndex < sentences.length - 1) {
                jumpToSentence(currentSentenceIndex + 1);
            } else {
                if (currentPageIndex < currentPages.length - 1) {
                    currentPageIndex++;
                    jumpToSentence(0);
                } else {
                    showToast("End of document");
                }
            }
        };

        function jumpToSentence(i) { 
            audioPlayer.pause();
            audioPlayer.src = "";
            currentSentenceIndex = i; 
            renderPage(); 
            if (!isPlaying) { 
                isPlaying = true; 
                const icon = document.getElementById('playIcon');
                if (icon) {
                    icon.setAttribute('data-lucide', 'pause');
                    lucide.createIcons();
                }
            } 
            playNext(); 
        }
        async function saveProgress() { if (currentDoc) await fetch(`${API_URL}/api/library`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ ...currentDoc, currentPage: currentPageIndex, lastSentenceIndex: currentSentenceIndex, lastAccessed: Date.now() }) }); }
        
        // Bidirectional Smart Scroll
        let isAutoFlipping = false;
        readerContent.addEventListener('wheel', (e) => {
            if (isAutoFlipping) return;
            
            const isAtBottom = readerContent.scrollTop + readerContent.clientHeight >= readerContent.scrollHeight - 10;
            const isAtTop = readerContent.scrollTop <= 10;
            
            // Scroll Down to Next Page
            if (e.deltaY > 0 && isAtBottom && currentPageIndex < currentPages.length - 1) {
                if (isPlaying) stopPlayback();
                isAutoFlipping = true;
                currentPageIndex++;
                currentSentenceIndex = 0;
                renderPage();
                readerContent.scrollTop = 0;
                saveProgress();
                setTimeout(() => { isAutoFlipping = false; }, 700);
            } 
            // Scroll Up to Previous Page
            else if (e.deltaY < 0 && isAtTop && currentPageIndex > 0) {
                if (isPlaying) stopPlayback();
                isAutoFlipping = true;
                currentPageIndex--;
                currentSentenceIndex = 0; // Or last sentence? Better to stay consistent.
                renderPage();
                // When going back, scroll to the BOTTOM of the previous page
                readerContent.scrollTop = readerContent.scrollHeight;
                saveProgress();
                setTimeout(() => { isAutoFlipping = false; }, 700);
            }
        }, { passive: true });

        speedRange.oninput = (e) => speedVal.textContent = parseFloat(e.target.value).toFixed(2);
        document.getElementById('prevPage').onclick = () => { if (currentPageIndex > 0) { currentPageIndex--; currentSentenceIndex = 0; renderPage(); if (isPlaying) playNext(); } };
        document.getElementById('nextPage').onclick = () => { if (currentPageIndex < currentPages.length - 1) { currentPageIndex++; currentSentenceIndex = 0; renderPage(); if (isPlaying) playNext(); } };
        pageInput.onchange = () => { let v = parseInt(pageInput.value)-1; if (v >= 0 && v < currentPages.length) { currentPageIndex = v; currentSentenceIndex = 0; renderPage(); if (isPlaying) playNext(); } };

        init();
    </script>
</body>
</html>
